# In a single-stepping through your code in a debugging setting,
# You often want to know the values of the local variables in your current function.
# You may also want to know the values of the locals in the parent function ––
# That is, the one from which the current function was called.
# Here, we will develop code to display these values,
# thereby further demonstrating access to the environment hierarchy.
# The code is adapted from my edtdbg debugging tool in R's CRAN code repository.)
# For example, consider the following code:

f <-function() {
  a <- 1
  return(g(a)+a)
}

g <- function(aa) {
  b <- 2
  aab <- h(aa+b)
  return(aab)
}

h <- function(aaa) {
  c <-3
  return(aaa+c)
}

# When we call f(), it in turn calls g(),
# which then calls h().
# In the debugging setting, say we are currently about to execute the return() within g().
# We want to know the values of the local variables of the current function, say the variables aa,b, and aab.
# And while we're in g(), we also wish to know the values of the locals in f() 
# at the time of the call to g(), as well as the values of the global variables.
# our function showframe() will do all this.
# The showframe() function has one argument, upn, which is the number of frames to go up the call stack.
# A negative value of the argument signals that we want to view the globals–– the top-level variables.
# Here's the code:

# shows the values of the local variables (including arguments) of the
# frame upon frames above the one from which showframe() is called; if
# upn < 0, the globals are shown; function objects are not shown
showframe <- function(upn) {
    # deterine the proper environment
    if (upn < 0) {
      env <- .GlovalEnv
  } else {
    env <- parent.frame(n=upn+1)
  }
  # get the list of variable names
  vars <- ls(envir=env)
  # for each variable name, print its value
  for (vr in vars) {
    vrg <- get(vr,envir=env)
    if (!is.function(vrg)) {
        cat(vr,":\n",sep="")
        print(vrg)
    }
  }
}

# Let's try it out. Insert some calls into g():

> g
function(aa) {
  b <- 2
  showframe(0)
  showframe(1)
  aab <- h(aa+b)
  return(aab)
}

# Now run it:

> f()
aa:
[1] 1
b:
[1] 2
a:
[1] 1

# To see how this works, we'll first look at the get() function,
# one of the most useful utilities in R. Its job is quite simple:
# Given the name of an object, it fetches the object itself. Here's an example:

> m <- rbind(1:3,20:22)
> m
    [,1] [,2] [,3]
[1,]   1    2    3
[2,]  20   21   22
> get("m")
      [,1] [,2] [,2]
[1,]     1    2    3
[2,]    20   21   22

# This example with m involves the current call frame,
# but in our showframe() function,
# we deal with various levels in the environment hierarchy.
# So, we need to specify the level via the envir argument of get():

vrg <- get(vr,envir=env)

# The level itself is determined largely by callling parent.frame():

if (upn < 0) {
   env <- .GlobalEnv
} else {
   env <- parent.frame(n=upn+1)
}

# Note that ls() can also be called in the context of a particular level,
# thus enabling you to determine which variables exist at the level of interest and then inspect them. Here's an example:

vars <- ls(envir=env)
for (vr in vars) {

# This code picks up the names of all the local variables in the given frame 
# and then loops through them, setting things up for get() to do its work.
