# Standard Chinese, often referred to as Mandarin outside China, is officially termed putonghua or guoyu.
# mapsound() useful for a list of tranformations and their frequencies of occurence. It relies on some support functions.

# we'll call x the source value, with h, s, and so on being the mapped values.

# Here are the formal parameters:

# df: A data frame consisting of the pronunciation data of two fangyan
# fromcol and tocol: Names in df of the source and mapped columns
# sourceval: The source value to be mapped, such as x in the preceding example

# Here is the head of a typical two-fangyan data frame, canma8, that would be used for df:

> head(canman8)
  Ch char    Can    Man    Can cons    Can Sound    Can  tone Man cons Man sound Man tone
1           yat1    yi1           y           at            1        y         i 1
2          ding1  ding1           d          ing            1        d       ing 1
3          chat1    qi1          ch           at            1        q         i 1
4         jeung6 zhang4           j         eung            6       zh       ang 4
5         seung5 shang4           s         eung            5       sh       ang 3
6            ha5   xia4           h            a            5        x        ia 4

# The function returns a list consisting of two components:

# counts: A vector of integers, indexed by the mapped values, showing the counts of those values.
# The elements of the vector are named according to the mapped values.
# Images: A list of character vectors. Again, the indices of the list are the mapped values,
# and each vector consists of all the characters that correspond to the geven mapped value.

# To make this concrete, let's try it out:

> m2cx <- mapsound(canman8,"Man cons","Can cons","x")
> m2cx$counts
ch f g h   j k kw n  s  y
15 2 1 87 12 4  2 1 81 21

# We see that x maps to ch 15 times, to f 2 times, 
# and so on. Note that we could have called sort() to m2cx$counts 
# to view the mapped images in order, from most to least frequent.

# the mandarin-speaking learner of Cantonese can then see that if they wish to know the 
# Cantonese pronunciation of a word whose Mandarin romanized form begins with x,
# the Cantonese almost certainly begins with h or s.
# Little aids like this should help the learning process quite a bit.

# To try to discern more patterns, 
# the learner may wish to determine in which characters x maps to ch, for example.
# We know from the result of the preceding example that there are six such characters.
# Which ones are they?
# That information is stored in images.
# The latter, as mentioned, is a list of vectors.
# We are interested in the vector corresponding to ch:

> head(m2cx$images[["ch"]])
    Ch  char    Can  Man  Can  cons  Can sound  Can  tone  Man  cons  Man  sound  Man  tone
613           chau3 xiu4         ch         au          3          x          iu  4
982           cham4 xin2         ch         am          4          x          in  2
1050          chun3 xun2         ch         un          3          x          un  2
1173          chui4  xu2         ch         ui          4          x           u  2
1184          chun3 xun2         ch         un          3          x          un  2
1566           che4 xie2         ch          e          4          x          ie  2

# Now, let's look at the code, Before viewing the code for mapsound() itself,
# let's consider another routine we need for support.
# It is assumed here that the data frame df that is input to mapsound() is produced by merging two frames for individual fangyans.
# In this case, for instance, the head of the Cantonese input frame is as follows:

> head(can8)
  Ch char  Can
1         yat1
2        yuet3
3        ding1
4        chat1
5        naai5
6         gau2

# The one for Mandarin is similar. We need to merge these two frames into canman8, seen earlier. 
# The code is written so that this operation not only combines the frames 
# but also separates the romanization of a character into initial consonant,
# the remainder of the romanization, and a tone number.
# for example, ding1 is separated into d, ing, and 1.

# We could similarly explore transformations in the other direction, 
# from Cantonese to Mandarin, and involving the nonconsonant remainders of characters.
# For example, this call determines which characters have eung as the nonconsonant portion of their Cantonese Pronunciation:

> c2meung <- mapsound(canman8,c("Can cons","Man cons"),"eung")

# We could then investigate the associated Mandarin sounds.
# Here is the code to accomplish all this:

# merges data frames for 2 fangyans
merge2fy <- function(fy1,fy2) {
    outdf <- merge(fy1,fy2)
    # separate tone from sound, and create new columns
    for (fy in list(fy1,fy2)) {
      # saplout will be a matrix, init cons in row 1, remainders in row # 2, and tones in row 3
      saplout <- apply((fy[[2]]),sepsoundtone)
      # convert it to a data frame
      tmpdf <- data.frame(fy[,1],t(saplout),row.names=NULL,
        stringsAsFactors=F)
      # add names to the columns
      consname <- paste(names(fy)[[2]],"cons",sep="")
      restname <- paste(names(fy)[[2]]," sound", sep="")
      tonename <- paste(names(fy)[[2]]," tone",sept="")
      names(tmpdf) <- c("Ch char",consname,restname,toename)
      # need to use merge(), not cbind(), due to possibly different 
      # ordering of fy, outdf
      outdf <- merge(outdf,tmpdf)
    }
    return(outdf)
}

# separate romanized pronunciation pronun into intitial consonant, is any,
# the remainder of the sound, and the tone, if any
sepsoundtone <- function(pronoun) {
  nchr  <- nchar(pronun)
  vowels <- c("a","e","i","o","u")
  # how many initial consonants?
  numcons <- 0
  for (i in 1:nchr) {
    ltr <- substr(pronun,i,i)
    if (!ltr %in% vowels) numcons <- numcons + 1 else break
  }
  cons <- if (numcons > 0) substr(pronun,1,numcons) else NA
  tone <- substr(pronun,nchr,nchr)
  numtones <- tone %in% letters # T is 1, F is 0
  if (numtones == 1) tone <- NA
  therest <- substr(pronun,numcons+1,nchr-numtones)
  return(c(cons,therest,tone))
}

# So, even the merging code is not so simple. And this code makes some simplifying assumptions,
# Excluding some important cases.
# Textual analysis is never for the faint of heart!

# Not surprisingly, the merging process begins with a call to merge(),
# in line 3. This creates a new data frame, outdf, to which we will append new columns
# for the separated sound components.
# The real work, then, involves the separation of a romanization into sound components,
# For that, there is a loop in line 5 across the two input data frames.
# In each iteratioin, the current data frame is split into sound components,
# With the result appended to outdf in line 19.
# Note the comment preceding that line regarding the unsuitability of cbing() in this situation.
# The actual separation into sound componenets is done in line 8.
# Here, we take a column of romanizations, such as the following:

yat1
yuet3
ding1
chat1
naai5
gau2

# We split it into three columns, consisting of initial consanant, remainder of the sound, and tone.
# For instance, yat1 will be split into y, at, and 1.
# This is a very natural candidate for some kind of "apply" function, 
# and indeed sapply() is used in line 8.
# Of course, this call requires that we write a suitable function to be applied.
# Of course, this call requires that we write a suitable function to be applied
# (If we had been lucky there would have been an existing R function that worked, but no such good fortune here.)
# The function we use is sepsoundtone(), starting in line 26.

# The sepsoundtone() function makes heavy use of R's substr() for sub-string function,
# described in detail in Chapter 11.
# In line 31, for example, we loop until we collect all the initial consonants, such as ch,
# The return value, in line 40, 
# consists of the three sound components extracted from the given romanized form,
# The formal parameter pronun.

# Note the use of R's built-in constant, letters, in line 37. 
# We use this to sense whether a given character is numberic,
# which means it's a tone.
# Some romanizations are toneless.

# Line 8 will then return a 3-by-1 matrix,
# with one row for each of the three sound components.
# We wish to convert this to a data frame for merging with outdf in line 19,
# and we prepare for this in line 10.

# Note that we call the matrix transpose function t() to put our information into columns rather than rows.
# This is needed because data-frame storage is by columns,
# Also, we include a column fy[,1], the Chinese characters themselves, 
# to have a column in common in the call to merge() in line 19.

# Now let's turn to the code for mapsound(),
# which actually is simpler than the preceding merging code.

mapsound <- function(df,fromcol,tocol,sourceval) {
    base <- which(df[[fromcol]] == sourceval)
    basedf <- df[base,]
    # determine which rows of basedf correspond to the various mapped
    # values
    sp <- split(basedf,basedf[[tocol]])
    retval <- list()
    retval$counts <- sapply(sp,nrow)
    retval$images <- sp
    return(retval)
}

# Recall that the argument df is the two-fanghan data frame,
# output from merge2fy().
# The arguments fromcol and tocol are the names of the source and mapped columns.
# The string sourceval is the source value to be mapped.
# For concreteness, consider the earlier examples in which sourceval was x.

# The first task is to determine which rows in df correspond to sourceval.
# This is accomplished via a straightforward application of which() in line 2.

# In the latter frame, consider the form that basedf[[tocol]] will take in line 6.
# These will be the values that x maps to––that is, ch, h, and so on.
# The purpose of line 6 is to determine which rows of basedf  contain which of these mapped values.
# Here we use in R's split() function.
# We'll discuss split() in detail in Section 6.2.2, 
# but the salient point is that sp will be a list of data frames: one of ch, one for h and so on.

# This sets up line 8. Since sp will be a list of data frames –– one for each mapped value
# applying the nrow() function via sapply() will give us the counts of the numbers of characters for each of the mapped values,
# such as the number of characters in which the map x → ch occurs (15 times, as seen in the example call).

# The complexity of the code here makes this a good time to comment on programming style.
# Some of us might point out, correctly, that lines 2 and 3 could be replaced by a one-liner:

basedf <- df[df[[fromcol]] == sourceval,]

# but we can see that line, with its numerous brackets, is harder to read.
# My personal preference is to break down operations if they become too complex.

# Similarly, the last few lines of code could be compacted to another one-liner:

list(counts=sapply(sp,nrow),images=sp)

# Among other things, this dispenses with the return(), concievably speeding up the code.
# Recall that in R, the last value computed by a function is automatically returned anyway,
# without a return() call. 
# However, the time savings here are really small and rarely matter,
# but we can also see that including the return() call is clearer.
