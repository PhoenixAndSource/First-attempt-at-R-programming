# Web search and other types of textual data mining are of great interest today.
# Let's use this area for an example of R list code.
# We'll write a function called findwords() that will determine which words are in a text file 
# and compile a list of the locations of each word's occurences in the text.
# This would be useful for contextual analysis, for example.
# Suppose our input file, testconcord.txt has the following contents

The [1] here means that the first item in this line of output is
item 1. In this case, our output consists of only one line (and one item), 
so this is redundant, but this notation helps to read voluminous output
that consists of many items spread over many lines.
For example, if there were two rows of output with six items per row,
the second row would be labeled [7].

# In order to identify words, 
# we replace all nonletter characters 
# with blanks and get rid of capitalization.
# We could use the string functions presented in Chapter 11 to do this,
# But to keep matters simple,
# such code is not shown here.
# The new file, testconcorda.txt, looks like this:

the    here means that the first item in this line of output is 
item    in this case our output consists of only one line and one
item so this is redundant but this notation helps to read 
voluminous output that consists of many items spread over many
lines for example if there were two rows of output with six items
per row the second row would be labeled

# Then, for instance, the word item has locations 7, 14, and 27, 
# which means that it occupies the seventh, fourteenth, and twenty-seventh word
# positions in the file.
# Here is an excerpt from the list that is returned when our function findwords() is called on this file:

> findwords("testconcorda.txt")
Read 68 items
$the
[1] 1 5 63

$here
[1] 2

$means
[1] 3

$that
[1] 4 40

$first
[1] 6

$item
[1] 7 14 27
...

# the list consists of one component per word in the file,
# with a word's component showing the positions within the file,
# where that word occurs.
# sure enough, the word item is shown as occuring at positions 7,14 and 27.
# Before looking at the code, let's talk a bit about out choice of a list structure here.
# One alternative would be to use a matrix, with one row per word in the text.
# We could use rownames() to name the rows,
# with the entries within a row showing the positions of that word.
# For instance, row item would consist of 7, 14, 27, and then 0s in the remainder of the row.
# But the matrix approach has a couple of major drawbacks:

# There is a problem in terms of the columns to allocate for our matrix.
# If the maximum frequency with which a word appears in our text is, say, 10,
# We would need 10 columns. But we would not know that ahead of time.
# We could add a new column each time we encountered a new word, using cbind() 
# in addition to using rbind() to add a row for the word itself().
# Or we could write code to do a preliminary run through the input file 
# to determine the maximum word frequency.
# either of these would come at the expense of increased code complexity and possibly increased runtime.

# such a storage scheme would be quite wasteful of memory,
# since most rows would probably consist of a lot of zeros.
# In other words, the matrix would be sparse.
# a situation that also often occurs in numberical analysis contexts.

# thus, the list structure really makes sense. Let's see how to code it.

findwords <- function(tf) {
  # read in the words from the file, into a vector of mode character
  txt <- scan(tf,"")
  wl <- list()
  for (i in 1:length(txt)) {
    wrd <- txt[i] # ith word in input file
    w1[[wrd]] <- c(w1[[wrd]],i)
  }
  return(wl)
}

# We read in the words of the file (words simply meaning any groups of letters separated by spaces)
# by calling scan(). The details of reading and writing files are covered in Chapter 10, 
# but the important point here is that txt will now be a vector of strings:
# one string per instance of a word in the file.
# Here is what txt looks like after the read:

> txt
 [1]  "the"        "here"    "means"      "that"      "the"
 [6]  "first"      "item"    "in"         "this"      "line"
 [11] "of"         "output"  "is"         "item"      "in"
 [16] "this"       "case"    "our"        "output"    "consists"
 [21] "of"         "only"    "one"        "line"      "and"
 [26] "one"        "item"    "so"         "this"      "is"
 [31] "redundant"  "but"     "this"       "notation"  "helps"
 [36] "to"         "read"    "voluminous" "output"    "that"
 [41] "consists"   "of"      "many"       "items"     "spread"
 [46] "over"       "many"    "lines"      "for"       "example"
 [51] "if"         "there"   "were"       "two"       "rows"
 [56] "of"         "output"  "with"       "six"       "items"
 [61] "per"        "row"     "the"        "second"    "row"
 [66] "would"      "be"      "labeled"

 # The list operations in lines 4 through 8 build up our main variable, 
 # a list wl (for word list). We loop through all the words from our long line,
 # with wrd being the current one.

 # Let's see what happens with the code in line 7 when i = 4, 
 # so that wrd = "that" in our example file testconcorda.txt.
 # At this point, wl[["that"]] will not yet exist.
 # As mentioned, R is set up so that in such a case, w1[["that"]] = NULL,
 # which means in line 7, we can concatenate it!
 # thus w1[["that"]] will become the one-element vector (4).
 # Later, when i = 40, wl[["that"]] will become (4,40), representing the fact that words 4 and 40 in the file are both "that".
 # Note how convenient it is that list indexing can be done through quoted strings, such as in wl[["that"]].
 # An advanced, more elegant version of this code uses R's split() function, as you'll see in Section 6.2.2.
