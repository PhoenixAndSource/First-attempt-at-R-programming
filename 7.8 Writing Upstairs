# As mentioned earlier, code that exists at a certain level of the environment hierarchy 
# has at least read access to all the variables at the levels above it.
# On the other hand, direct write access to variables at higher levels via the standard
# <- operator is not possible.

# If you wish to write to a global variable––or more generally, to any variable higher 
# in the environmental hierarchy than the level at which your write statement exists––
# you can use the superassignment operator, <<-, or the assign() function.
# let's discuss the superassignment operator first.

7.8.1 Writing to Nonlovals with the Superassignment Operator
# Consider the following code:

> two <- function(u) {
+    u <<- 2*u
+    z <- 2*z
+ }
> x <- 1
> z <- 3
> u
Error: object "u" not found
> two(x)
> x
[1] 1
> z
[1] 3
> u
[1] 2

# Let's look at the impact (or not) on the three top-level variables x,z, and u:

# x: Even though x was the actual argument to two() in the example, it
#  retained the value 1 after the call. This is because its value 1 was copied
#  to the formal argument u, which is treated as a local variable within the function.
#  thus, when u changed, x did not change with it.

# z: The two z values are entirely unrelated to each other–– one is top level,
# and the other is local to two(). The change in the local variable has no effect on the global variable.
# Of course, having two variables with the same name is probably not good programming practice.

# u: The u value did not even exist as a top-level variable prior to our calling two(), hence the "not found" error message.
# However, it was created as a top-level variable by the superassignment operator within two(), as confirmed after the call.

# Though <<- is typically used to write to top-level variables,
# as in our example, technically, it does something a big different.
# use of this operator to write to a variable w will result in a search up the environment hierarchy,
# stopping at the first level at which a variable of that name is encountered.
# If none is found, then the level selected will be global.
# Look what happens in this little example:

> f
function() {
  inc <- function(){x <<- x + 1}
  x <- 3
  inc()
  return(x)
}
> f()
[1] 4
> x
Error: object 'x' not found

# Here, inc() is defined within f(). When inc() is executing, and the R
# interpreter sees a superassignment to x, it starts going up the hierarchy.
# At the first level up––the environment within f()––it does find an x,
# and so that x is the one that is written to, not x at the top level.
