# 1.3 Intro to Functions

# R programming consists of writing functions
# A function is:
# - a group of instructions that takes inputs
# - uses them to compute other values 
# - returns a result

# example function named oddcount() 
# - purpose is to count the odd numbers in a vector of integers.
# - normally we  compose the function code using a text editor and save it in a file,
# - but in this example, we enter it line by line in R's interactive mode.
# - then we'll call the function on a couple of test cases.

# counts the number of odd integers in x
> offcount <- function(x) {
+    k <- 0 # assign 0 to k
+    for (n in x) {
+       if (n %% 2 == 1) k <- k+1 # %% is the modulo operator
+    }
+    return(k)
+ }
> oddcount(c(1,3,5))
[1] 3
> oddcount(c(1,2,3,7,9))
[1] 4

# First we told R that we wanted to define a function named oddcount with one argument, x.
# the left brace demarcates the start of the body of the function.
# We wrote one R statement per line.
# Until the body of the function is finished, 
# - R reminds you that you're still in the definition by using + as its prompt, instead of the usual >.
# + is a line-continuation character, not a prompt for a new input.
# R resumes the > prompt after you finally enter a right brace to conclude the function body.

# after defining the function, we evaluated two calls to oddcount(). 
# Since there are three odd numbers in the vector (1,3,5), the call oddcount(c(1,3,5)) returns the value 3.
# There are four odd numbers in (1,2,3,7,9), so the second call returns 4.
# the modulo operator for remainder arithmetic is %% in R which is noted in the comment.
# For example, 38 divided by 7 leaves a remainder of 3:

> 38 %% 7
[1] 3

# another example:

for (n in x) {
  if (n %% 2 == 1) k <- k+1
}

# First it set n to x[1] then tests that value for being odd or even.
# If the value is odd, in this case, the count variable k is incremented.
# n is set to x[2] tested for being odd or even and so on.

# C/C++ programmers may be tempted to write loop lilke this:
for (i in 1:length(x)) {
  if (x[1] %% 2 ==1) k <- k+1
}

# here, length(x) is the number of elements in x.
# if there are 25 elements, then 1:length(x) means 1:25, which means, 1,2,3,...,25.
# this code would also work (unless x were to have length 0), but one of the major themes of R programming is to avoid loops if possible
# if not, keep loops simple.

# our original formulation:
for (n in x) {
  if (n %% 2 == 1) k <- k+1
}
# which is simple and cleaner because we do not need to use the length() function and array indexing.
# at the end of the code, we use the return statement:
return(k)
# this makes the function return the computed value of k to the code that called it.
k
# simply k also works.
# R functions will return the last value computed if there is no explicit return() call. However, use this with care (section 7.4.1.)
# in programming language, x is the formal argument (or formal parameter) of the function oddcount(). 
# In the first function call in the preceding example, c(1,3,5) is referred to as the actual argument.
# these terms allude to the fact that x in the function definition is just a placeholder.
# c(1,3,5) is the value actually used in the computation.
# in the second function call, c(1,2,3,7,9) is the actual argument.

# 1.3.1 Variable Scope
# A variable visible only within a function body means that it is "local" to that function.
# In oddcount(), k and n are local variables. They disappear after the function returns:

> oddcount(c(1,2,3,7,9))
[1] 4
> n
Error: object 'n'not found

# note that formal parameters in an R function are local variables. Make the following function call:
> z <- c(2,6,7)
> oddcount(z)

# suppose that the code of oddcount() changes x. then z would not change.
# after the call to oddcount(), z would have the same value as before. 
# To evaluate a function call, R copies each actual argument to the corresponding local paramater variable,
# and changes to that variable are not visible outside the function.
# Scoping rules (Chapter 7)
# Variables created outside functions are global and are available within functions as well.
# Example:
> f <- function(x) return(x+y)
> y <-3
> f(5)
[1] 8
# here y is a global variable
# global variable can be written to from within a function by using R's superassignment operator, <<-. (Chapter 7)

# 1.3.2 Default Arguments
# "Default Arguments"

> g <- function(x,y=2,z=t) { ... }

# y initializes/ sets to the vale "2" if programmer does not specify y in the call. In other words, default is 2.
# z will have the default value TRUE.

> g(12,z=FALSE)

# value 12 is the actual argument for x
# we accept the default value of 2 for y
# We override the default for z, setting its value to FALSE
# R has a Boolean type meaning it has the logical values, TRUE and FALSE
# TRUE and FALSE can be abbreviated T and F, but may avoid these abbreviations if T and F are variables.

# 1.4 Some R Data Structures
# elements of a vector must have the same "mode" or data type.
# you can have a vector consisting of three character strings (of mode character) or three integer elements (of mode integer)
# but not a vector with one integer element and two character string elements.

# 1.4.1.1 Scalars
# Scalars, meaning individual numbers do not exist in R: 
# what looks like individual numbers are actually one-element vectors.

> x <- 8
> x 
[1] 8

# [1] element 1 of a vector, in this case, x[1]. 
# R is treating x as a vector, a vector with just one element.

# 1.4.2. Character Strings
# Character strings are single-element vectors of mode character, (rather than mode numeric)

> x <- c(5,12,13)
> x 
[1] 5 12 13
> length(x)
[1] 3
> mode(x)
[1] "numeric"
> y <- "abc"
> y
[1] "abc"
> length(y)
[1] 1
> mode(y)
[1] "character"
> z <- c("abc","29 88")
> length(z)
[1] 2
> mode(z)
[1] "character"

# in the first example, we create a vector x of numbers, which is mode numeric,
# we create two vectors of mode character: y is a one-element (that is, one-string) vector, 
# z consists of two strings.

# R has various string-manipulation functions.
# Many deal with putting strings together or taking them apart:

> u <- paste("abc","de","f") # concatenate the strings
> u
[1] "abc de f"
> v <- strsplit(u,"") # split the string according to blanks
> v
[[1]]
[1] "abc" "de" "f"

# strings in Chapter 11




