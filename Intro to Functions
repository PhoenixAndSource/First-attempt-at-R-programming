# 1.3 Intro to Functions

# R programming consists of writing functions
# A function is:
# - a group of instructions that takes inputs
# - uses them to compute other values 
# - returns a result

# example function named oddcount() 
# - purpose is to count the odd numbers in a vector of integers.
# - normally we  compose the function code using a text editor and save it in a file,
# - but in this example, we enter it line by line in R's interactive mode.
# - then we'll call the function on a couple of test cases.

# counts the number of odd integers in x
> offcount <- function(x) {
+    k <- 0 # assign 0 to k
+    for (n in x) {
+       if (n %% 2 == 1) k <- k+1 # %% is the modulo operator
+    }
+    return(k)
+ }
> oddcount(c(1,3,5))
[1] 3
> oddcount(c(1,2,3,7,9))
[1] 4

# First we told R that we wanted to define a function named oddcount with one argument, x.
# the left brace demarcates the start of the body of the function.
# We wrote one R statement per line.
# Until the body of the function is finished, 
# - R reminds you that you're still in the definition by using + as its prompt, instead of the usual >.
# + is a line-continuation character, not a prompt for a new input.
# R resumes the > prompt after you finally enter a right brace to conclude the function body.

# after defining the function, we evaluated two calls to oddcount(). 
# Since there are three odd numbers in the vector (1,3,5), the call oddcount(c(1,3,5)) returns the value 3.
# There are four odd numbers in (1,2,3,7,9), so the second call returns 4.
# the modulo operator for remainder arithmetic is %% in R which is noted in the comment.
# For example, 38 divided by 7 leaves a remainder of 3:

> 38 %% 7
[1] 3

# another example:

for (n in x) {
  if (n %% 2 == 1) k <- k+1
}

# First it set n to x[1] then tests that value for being odd or even.
# If the value is odd, in this case, the count variable k is incremented.
# n is set to x[2] tested for being odd or even and so on.

# C/C++ programmers may be tempted to write loop lilke this:
for (i in 1:length(x)) {
  if (x[1] %% 2 ==1) k <- k+1
}

# here, length(x) is the number of elements in x.
# if there are 25 elements, then 1:length(x) means 1:25, which means, 1,2,3,...,25.
# this code would also work (unless x were to have length 0), but one of the major themes of R programming is to avoid loops if possible
# if not, keep loops simple.

# our original formulation:
for (n in x) {
  if (n %% 2 == 1) k <- k+1
}
# which is simple and cleaner because we do not need to use the length() function and array indexing.
# at the end of the code, we use the return statement:
return(k)
# this makes the function return the computed value of k to the code that called it.
k
# simply k also works.
# R functions will return the last value computed if there is no explicit return() call. However, use this with care (section 7.4.1.)
# in programming language, x is the formal argument (or formal parameter) of the function oddcount(). 
# In the first function call in the preceding example, c(1,3,5) is referred to as the actual argument.
# these terms allude to the fact that x in the function definition is just a placeholder.
# c(1,3,5) is the value actually used in the computation.
# in the second function call, c(1,2,3,7,9) is the actual argument.

# 1.3.1 Variable Scope
# A variable visible only within a function body means that it is "local" to that function.
# In oddcount(), k and n are local variables. They disappear after the function returns:

> oddcount(c(1,2,3,7,9))
[1] 4
> n
Error: object 'n'not found

# note that formal parameters in an R function are local variables. Make the following function call:
> z <- c(2,6,7)
> oddcount(z)

# suppose that the code of oddcount() changes x. then z would not change.
# after the call to oddcount(), z would have the same value as before. 
# To evaluate a function call, R copies each actual argument to the corresponding local paramater variable,
# and changes to that variable are not visible outside the function.
# Scoping rules (Chapter 7)
# Variables created outside functions are global and are available within functions as well.
# Example:
> f <- function(x) return(x+y)
> y <-3
> f(5)
[1] 8
# here y is a global variable
# global variable can be written to from within a function by using R's superassignment operator, <<-. (Chapter 7)

