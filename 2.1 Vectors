# Vectors
# Main data type in R is the vector.
# We'll look at how vectors relate to some other data types in R
# in R, individual numbers (scalars) do not have a separate data type (unlike C family languages)
# individual numbers are special cases of vectors. 
# (in C family languages, matrices are special cases of vectors)

# Recycling - the automatic lengthening of vectors in certain settings
# Filtering - the extraction of subsets of vectors
# Vectorization - where functions are applied element-wise to vectors

# All these operations are central to R programming

# 2.1 Scalars, Vectors, Arrays, and Matrices.

# vector variables are considered different from scalars (single-number variables).

# The following is an example of C code:
int x;
int y[3];
# This requests the compiler to allocate space 
# for a single integer named x 
# and a three-element integer array (C terminology comparable to R's vector type) named y.

# but in R, numbers are actually considered one-element vectors, and has no such thing as scalar.
# R variable types are called modes.
# All elements of a vector must have the same mode, 
# which can be integer, numeric (floating-point number), character (string), logical (Boolean), complex, etc.
# If you need program code to check the variable x, query it  by the call typeof(x).
# vector indices in R begin at 1. (unlike vector indices in ALGOL-family languages, such as C and Python)

# 2.1.1 Adding and Deleting Vector Elements.
# Vectors are stored like arrays in C, contiguously (connecting to/ next to) 
# That's why you cannot insert or delete elements (which you can do in Python)
# The size of a vector is determined at its creation
# So if you want to add or delete elements, 
# you'll have to reassign the vector
# example: add an element to the middle of a four-element vector:
> x <- c(88,5,12,13)
> x <- c(x[1:3],168,x[4]) # insert 168 before the 13
> x 
[1] 88 5 12 168 13

# Here we created a four-element vector and assigned it to x. 
# To insert a new number 168 between the third and fourth elements,
# we strung together the first three elements of x,
# then the 168, 
# then the fourth element of x.
# This creates a new five-element vector, leaving x intact for the time being
# We then assigned that new vector to x.

# in the result, it appears as if we had actually changed the vector stored in x,
# but really we created a new vector and stored that vector in x.
# this difference may seem subtle but it has implications.
# for instance, in some cases, it may restrict the potential for fast performance in R (chapter 14)

# 2.1.2 Obtaining the length of a Vector
# You can obtain the length of a vector by using the length() function:
> x <- c(1,2,4)
> length(x)
[1] 3

# In this example, we already know the length of x, so there really is no need to query it.
# But in writing general function code, you'll often need to know the lengths of vector arguments.
# make a function that determines 
# the index of the first 1 value 
# in the function's vector argument
# (assuming we are sure there is such a value)
# here is one way to write the code:

first1 <- function(x) {
  for (i in 1:length(x)) {
    if (x[1] == 1) break # break out of loop
  }
  return(i)
}

# Without the length() function, 
# we would have needed to add a second argument to first1(), 
# like naming it n, to specify the length of x.
# note in this case, writing the loop as follows won't work:
for (n in x)
# The problem with this approach it doesnt allow us to retrieve the index of the desired element
# thus we need an explicit loop, which in turn requires the calculating the length of x

# in coding be careful that length(x) might be 0
# in such a case, look what happens to the expression 1:length(x) i our for loop:
> x <- c()
> x
NULL
> length(x)
[1] 0
> 1:length(x)
[1] 1 0

# Our variable i in this loop takes on the value 1, then 0, which is certainly not what we want if the vector x is empty.
# A safe alternative is to use the more advanced R function seq(), as we'll discuss in section 2.4.4

# 2.1.3. Matrices and Arrays as Vectors
# arrays and matrices (and even lists, in a sense) are actually vectors too.
# they merely have extra class attributes
# For example, matrices have the number of rows and columns
# arrays and matrices are vectors,
# everything we say about vectors applies to them too.
# Example:

> m
  [,1] [,2]
[1,]  1  2
[2,]  3  4
> m + 10:13
  [,1] [,2]
[1,]  11  14
[2,]  14  17

# the 2-by-2 matrix m is stored as a four-element vector, column-wise, as (1,3,2,4)
# we then added (10,11,12,13) to it, yielding (11,14,14,17), 
# but R remembered that we were working with matrices and thus gave us the 2-by-2 result you see in the example.

# 2.2 Declarations
# Typically, compiled languages require that you declare variables; that is warn the interpreter/ compiler of the variables' existence before using them.
# this is the case in our earlier C example.

int x;
int y[3];

# As with most scripting languages (such as Python and Perl), 
# you do not declare variables in R)
# example
z <- 3
# this code, with no previous reference to z, is perfectly legal (and common-place).
# however, if you reference specific elements of a vector, you must warn R. 
# For instance, say we wish y to be a two-component vector with values 5 and 12

# The following will not work:
> y[1] <- 5
> y[2] <- 12

# Instead, you must create y first, for instance this way:
> y <- vector(length=2)
> y[1] <- 5
> y[2] <-12

# Instead you must create y first:
> y <- vector(length=2)
> y[1] <- 5
> y[2] <-12

# The following will also work
> y <- c(5,12)
# This approach is all right because on the right-hand sided we are creating a new vector, to which we then bind y.
# The reason we cannot suddenly spring an expression like y[2] on R stems from R's functional language nature.
# The reading and writing of individual vector elements are actually handled by functions.
# If R doesn't already know that y is a vector, these functions have nothing on which to act.
# Just as variables are not declared, they are not constrained in terms of mode. 

# The following sequence of events is perfectly valid:

> x <- c(1,5)
> x
[1] 1 5
> x <- "abc"

# First, x is associated with a numeric vector, then with a string. 
# (Again, for C/C++ programmers: x is nothing more than a pointer, which can point to different types of objects at different times.)

2.3 Recycling

# When applying an operation to two vectors that requires them to be the same length,
# R automatically recycles, or repeats, the shorter one,
# until it is long enough to match the longer one.
# Here is an example:

> c(1,2,4) + c(6,0,9,20,22)
[1] 7 2 13 21 24
Warning message:
longer object length
  is not a multiple of shorter object length in: c(1,2,4) + c(6,0,9,20,22)

# The shorter vector was recycled, so the operation was taken to be as follows:
> c(1,2,4,1,2) + c(6,0,9,20,22)

# Here's a more subtle example:
> x
  [,1] [,2]
[1,]  1  4
[2,]  2  5
[3,]  3  6
> x+c(1,2)
  [,1]  [,2]
[1,]  2  6
[2,]  4  6
[3,]  4  8

# keep in mind that matrices are actually long vectors. 
# Here, x, as a 3-by-2 matrix, is also a six-element vector,
# Which in R is stored column by column
# x is the same as c(1,2,3,4,5,6).
# We added a two-element vector to this six-element one
# so our added vector needed to be repeated twice to make six elements.
# x + c(1,2,1,2,1,2)
# also, c(1,2,1,2,1,2) was also changed from a vector to a matrix having the same shape as x before the addition took place:
1 2
2 1
1 2
# thus, the net result was to compute the following:
#  (  1 4        (  1 2
#     2 5    +      2 1
#     3 6 )         1 2 )

# 2.4 Common Vector Operations
# common operations related to vectors
# arithmetic and logical operations, vector indexing, some useful ways to create vectors.

# 2.4.1 Vector Arithmetic and Logical Operations
# Remember that R is a functional language. 
# Every operator, including + in the following example is actually a function.
> 2+3
[1] 5
> "+"(2,3)
[1] 5

# Recall further that scalars are actually one-element vectors.
# add vectors, and the + operation will be applied element-wise.

> x <- c(1,2,4)
> x + c(5,0,-1)
[1] 6 2 3

# if you are familiar with linear algebra, 
# you may be surprised at what happens when we multiply two vectors:
> x * c(1,2,4)
[1] 5 0 -4

# But remember, because of the way the * function is applied, the multiplication is done element by element.
# The first element of the product (5) 
# is the result of the first element of x (1) 
# being multiplied by the first element of c(5,0,1)(5)

# the same principle applies to other numeric operators.
# Here's an example: 
> x <- c(1,2,4)
> x / c(5,4,-1)
[1]  0.2 0.5 -4.0
> x %% c(5,4,-1)    # %% means modulus which is the remainder when you divide.
[1] 1 2 0

# 2.4.2  Vector Indexing
# indexing vectors - we form a subvector  by picking elements of the given vector for specific indices.
# the format is vector1[vector2]
> y <- c(1.2,3.9,0.4,0.12)
> y[c(1,3)] # extract elements 1 and 3 of y
[1] 1.2  0.4
> y[2:3]
[1] 3.9 0.4
> v <- 3:4
> y[v]
[1] 0.40 0.12

# note that duplicates are allowed.

> x <- c(4,2,17,5)
> y <- x[c(1,1,3)]
> y
[1]  4  4  17

# negative subscripts mean that we want to exclude the given elements in our output.

> z <- c(5,12,13) 
> z[-1] # exclude element 1
[1] 12 13
> z[-1: -2]  # exclude elements 1 through 2
[1] 13

# In such contexts, it is often useful to use the length() function. 
# For instance, if we want to get all the elements of vector z except for the last:
> z <- c(5,12,13)
> z[1:(length(z)-1)]
[1]  5 12

# Or:
> z[-length(z)]
[1]  5  12
# this is more general than using z[1:2].
# Our program may need to work for more than just vectors of length 2
# and the second approach would give us that generality.

