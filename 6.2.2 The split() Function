# 6.2.2 The split() function

# In contrast to tapply(), which splits a vector into groups and applies a specified function on each group,
# split() stops at that first stage,
# just forming the groups.

# The basic form, without bells and whistles, is split(x,f), 
# with x and f playing roles similar to those in the call tapply(x,f,g);
# that is, x being a vecctor or data frame and f being a factor or a list of factors.
# The action is to split x into groups, which are returned in a list.
# (Note that x is allowed to be a data frame with split() but not with tapply().)
# Let's try it out with our earlier example.

> d
  gender age income over25
1      M  47  55000      1
2      M  59  88000      1
3      F  21  32450      0
4      M  32  76500      1
5      F  33 123000      1
6      F  24  45650      0
> split(d$income,list(d$gender,d$over25))
$F.0
[1] 32450 45650

$M.0
numeric(0)

$F.1
[1] 123000

$M.1
[1] 55000 88000 76500

# The output of split() is a list, and recall that list components are denoted by dollar signs.
# So the last vector, for example, was named "M.1" to indicate that it was 
# the result of combining "M" in the first factor and 1 in the second.

# As another example, consider our abalone example from Section 2.9.2.
# We wanted to determine the indices of the vector elements corresponding to male, female, and infant.
# The data in that little example consisted of the seven-observation vector
# ("M","F","F","I","M","M","F"), assigned to g.
# We can do this in a flash with split().

> g <- c("M","F","F","I","M","M","F")
> split(1:7,g)
$F
[1] 2 3 7

$I
[1] 4

$M
[1] 1 5 6

# The results show the female cases are in records 2,3, and 7;
# The infant case is in record 4; and the male cases are in records 1,5, and 6.

# Let's dissect this step-by-step.
# The vector g, taken as a factor,
# has three levels: "M", "F", and "I".
# The indices corresponding to the first level are 1,5, and 6, 
# which means that g[1],g[5], and g[6] all have the value "M".
# So, R sets the M component of the output to elements 1,5, and 6 of 1:7,
# which is the vector (1,5,6).

# We can take a similar approach to simplify the code in our text concordance example from Section 4.2.4.
# There, we wished to input a text file,
# determind which words were in the text, 
# and then output a list giving the words and their locations within the text.
# We can use split() to make short work of writing the code, as follows:

findwords <- function(tf) {
  # read in the words from the file, into a vector of mode character
  txt <- scan(tf,"")
  words <- split(1:length(txt),txt)
  return(words)
}

# The call to scan() returns a list txt of the words read in from the file tf.
# So, txt[[1]] will contain the first word input from the file, 
# txt[[2]] will contain the second word, and so on; length(txt) will thus be the total number of words read.
# Suppose for concreteness that that number is 220.

# Meanwhile, txt itself, as the second argumet in split() above,
# will be taken as a factor. The levels of that factor will be the various words in the file.
# If, for instance, the file contains the word world 6 times and climate was there 10 times,
# Then "world" and "climate" will be two of the levels of txt.
# The call to split() will then determine where these and the other words appear in txt.
