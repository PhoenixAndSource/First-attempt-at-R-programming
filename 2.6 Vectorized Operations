# If we have a function f() that we want to apply to all elements of a vector x,
# We can accomplish this by calling f() on x itself.
# This can simplify our code, and give us a dramatic performance increase of a hundredsfold or more.
# One of the most effective ways to achieve speed in R code is to use
# operations that are "vectorized"
# which means that a function applied to a vector is actually applied individually to each element.

# 2.6.1 Vector In, Vector Out
# You saw examples of vectorized functions earlier in the chapter, with the + and * operators. 
# Another example is >.

> u <- c(5,2,8)
> v <- c(1,3,9)
> u > v
[1]  TRUE FALSE FALSE

# Here, the > function was applied to u[1] and v[1]
# Resulting in TRUE, then to u[2] and v[2] resulting in FALSE, and so on.

# A key point is that if an R function uses vectorized operations, it too, is vectorized,
# thus enabling a potential speedup.
# Here is an example:

> w <- function(x) return(x+1)
> w(u)
[1] 6 3 9

# Here w() uses +, which is vectorized, so w() is vectorized as well.
# As you can see, there is an unlimited number of vectorized functions
# As complex ones are fuilt up from simpler one.
# Even the transcendental functions –– square roots, logs, trig functions, and so on––are vectorized.

> sqrt(1:9)
[1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
[9] 3.000000

# This applies to many other built-in R functions.
# For instance, let's apply the function for rounding to the nearest integer to an example vector y:

> y <- c(1.2,3.9,0.4)
> z <- round(y)
> z 
[1] 1 4 0

# The point is that the round() function is applied individually to each element in the vector y.
# And remember that scalars are really single-element vectors, 
# So the "ordinary" use of round() on just one number is merely a special case.

> round(1.2)
[1] 1

# Here, we used the built-in function round(), but you can do the same thing with functions
# that you write yourself.
# even operators such as + are actually functions. For example:

> y <- c(12,5,13)
> y+4
[1] 16 9 17

# The reason element-wise addition of 4 works here is that the + is actually a function!
# Here it is explicitly:

> '+'(y,4)
[1] 16 9 17

# Also, we are recycling 4. (4,4,4)
# Since we know that R has not scalars,
# Let's look at vectorized functions that appear to have scalar arguments.

> f 
function(x,c) return((x+c)^2)
> f(1:3,0)
[1] 1 4 9
> f(1:3,1)
[1] 4 9 16

# In our definition of f() here, we intend c to be a scalar, but
# it is actually a vector of length 1.
# Even using a single number for c in our call to f()
# It will be extended through recycling to a vector for our computation of x+c within f().
# So in our ccall f(1:3,1) in the example, 
# the quantity x+c becomes as follows:
# (1    (1
#  2  +  1
#  3)    1)
# But what about code safety? There is nothingi n f() that keeps us from using 
# an explicit vector for c, such as this example:
> f(1:3,1:3)
[1]  4 16  36
# You should work through the computation to confirm that (4,16,36) is indeed the expected output.
# If you really want to restrict c to scalars, 
# You should insert some kind of check, say this one:

> f
function(x,c) {
if (length(c) !=1) stop("vector c not allowed")
  return((x+c)^2)
}
